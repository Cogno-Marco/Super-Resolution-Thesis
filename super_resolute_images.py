import world_2d as w
import numpy as np

def mu(f, r):
    #if f > CAMERA_RESOLUTION: return mu(CAMERA_RESOLUTION)
    return 0.5 + 1/(2 * r) - f/(2 * r**2)
def epsilon(r):
    return 1/(2 * r**2 + 2 * r - 1)

class Bucket:
    
    def __init__(self, principal_voice, r):
        self.r = r
        self.k = len(principal_voice)
        self.principal = principal_voice
        self.photos = []
        self.photos.append(principal_voice)
    
    def is_photo_aligned(self, photo):
        currentGuesses = 0
        for i in range(len(photo)):
            for macro_guessed, macro_actual in zip(self.principal[i], photo[i]):
                if macro_guessed == macro_actual:
                    currentGuesses += 1
        
        return currentGuesses > ((self.k**2) / 2 + self.k * 3 / 4)
    
    def add_photo(self, photo):
        self.photos.append(photo)
    
    def get_photos(self):
        return self.photos
    
    def get_whites_count(self):
        whites = [[0 for _ in range(self.k)] for _ in range (self.k)]
        for photo in self.photos:
            for ind, line in enumerate(photo):
                whites[ind] = [val + count for val, count in zip(line, whites[ind])]
        return [[int(round(i*CAMERA_RESOLUTION/len(self.photos))) for i in line] for line in whites]
    
    def get_diff(self, bucket):
        diff = [[0 for _ in range(self.k)] for _ in range (self.k)]
        my_count = self.get_whites_count()
        his_count = bucket.get_whites_count()
        for ind in range(self.k):
            diff[ind] = [my_c - his_c for my_c, his_c in zip(my_count[ind], his_count[ind])]
        return diff

    def is_equal(self, bucket):
        #if the difference of each macro is 0, the zones are the same
        for line in self.get_diff(bucket):
            for count in line:
                if count != 0: return False
        return True

    def is_bucket_aligned(self, bucket):
        diff = self.get_diff(bucket)
        diff_sum = np.array(diff).sum()
        return abs(diff_sum) <= CAMERA_RESOLUTION / 8
        
        
        #if the difference is not in the range [-1,1] the buckets are NOT aligned
        diff = self.get_diff(bucket)
        for line in diff:
            for count in line:
                if count > 1 or count < -1: return False
        
        #they're also not aligned if, watching pixel by pixel, as one increases, the other increases too
        # or if one decreases the other decreases too
        #basically to be valid, +1 and -1 must alternate (ignoring 0s)
        
        for line in diff:
            parity = None
            for count in line:
                if count == 0: continue #ignore 0s
                if parity == None: 
                    parity = count #set starting parity as equal
                    continue
                if parity == count:
                    #if parity of the last change is the same as this, then it doesn't alternate, so this is not valid
                    return False
                else: parity = count
                
        return True


CAMERA_SIZE = 7
CAMERA_RESOLUTION = 64

#load world with image
world_2d = w.World2D(512)
PHOTOS_PER_OFFSET = 32

#Algorithm:

buckets_list = []

print("adding photos to buckets")

#for each try for each offset
for x in range(CAMERA_RESOLUTION+1):
    for _ in range(PHOTOS_PER_OFFSET):
        #Take a picture
        photo = world_2d.photo((x,0), CAMERA_SIZE, CAMERA_RESOLUTION)
        
        #for each bucket look if image can be generated by the bucket
        was_added = False
        for i,bucket in enumerate(buckets_list):
            if bucket.is_photo_aligned(photo):
                #if it can add photo to bucket
                bucket.add_photo(photo)
                was_added = True
                break
        
        #else create new bucket with the photo
        if not was_added:
            buckets_list.append(Bucket(photo, CAMERA_RESOLUTION))
            
print(f"photos added to buckets, total buckets={len(buckets_list)}")
#when I have enough photos

print("cleaning buckets")
clean_buckets = []
#join equal buckets together
for i in range(len(buckets_list)):
    main_bucket = buckets_list[i]
    for j in range(i, len(buckets_list)):
        if i == j: continue #skip compare to itself
        b2 = buckets_list[j]
        
        #if they're equal, fuse them together
        if main_bucket.is_equal(b2):
            for k,photo in enumerate(b2.get_photos()):
                #print(f"adding photo {k}")
                main_bucket.add_photo(photo)
    clean_buckets.append(main_bucket)
print(f"buckets cleaned, remaining {len(clean_buckets)} buckets")

print(len(clean_buckets[0].get_photos()))
print(clean_buckets[0].get_whites_count())
print(clean_buckets[1].get_whites_count())
print(clean_buckets[2].get_whites_count())
#link each bucket pair to create an order, knowing that near bucket cannot change micropixels by more than 1

for i in range(len(buckets_list)):
    main_bucket = buckets_list[i]
    for j in range(i, len(buckets_list)):
        if i == j: continue #skip compare to itself
        b2 = buckets_list[j]
        
        #if they're aligned, put them next to each other
        if main_bucket.is_bucket_aligned(b2):
            print(f"alignment buckets {i}, {j}")

        
        

#now that I have an order, find out how micropixels change to know how to place them
#if number of white micros increases by 1, a black micro exited and a white entered
#if number of micros decreases by 1, a white micro exited and a black entered
#if number of micros is equal, the micro entered is equal to the micro who exited
#also
#if number of white micros is 0, the whole piece is black
#if number of white micros is r, the whole piece is white